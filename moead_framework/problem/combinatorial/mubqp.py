import numpy as np
from moead_framework.problem.problem import Problem
from moead_framework.solution.one_dimension_solution import OneDimensionSolution


class Mubqp(Problem):
    """
    Implementation of the Multiobjective Unconstrained Binary Quadratic Programming problem.
    The problem is compatible with files generated
    by the mocobench generator http://mocobench.sourceforge.net/index.php?n=Problem.MUBQP

    Example:

    >>> from moead_framework.problem.combinatorial import Mubqp
    >>>
    >>> instance_file = "moead_framework/test/data/instances/mubqp_0_2_25_0.8_0.dat"
    >>> mubqp = Mubqp(instance_file=instance_file)
    >>>
    >>> # Generate a new solution
    >>> solution = mubqp.generate_random_solution()
    >>>
    >>> # Print all decision variables of the solution
    >>> print(solution.decision_vector)
    >>>
    >>> # Print all objectives values of the solution
    >>> print(solution.F)
    """

    dtype = float

    def __init__(self, instance_file: str):
        """
        Constructor of the problem

        :param instance_file: {string} text file generated by the mubqp generator : http://mocobench.sourceforge.net/index.php?n=Problem.RMNK#Code
        """
        if not isinstance(instance_file, str):
            raise TypeError("The expected type of `instance_file` is `str`")

        file = open(instance_file, 'r')
        file_content = list(map(str.strip, file.readlines()))
        file.close()

        file_content = file_content[6:]

        definition = file_content[0].split(" ")
        self.rho = float(definition[2])
        self.m = int(definition[3])
        self.n = int(definition[4])
        self.d = float(definition[5])
        file_content = file_content[2:]

        super().__init__(objective_number=self.m)

        self.qs = np.zeros((self.m, self.n, self.n))
        self.load_qs(file_content)

    def f(self, function_id: int, decision_vector:np.ndarray):
        """
        Evaluate the decision_vector for the objective function_id

        :param function_id: {integer} index of the objective
        :param decision_vector: {:class:`~moead_framework.solution.one_dimension_solution.OneDimensionSolution`} solution to evaluate
        :return: {float} fitness value
        """
        if not isinstance(function_id, int):
            raise TypeError("The expected type of `function_id` is `int`")

        if not isinstance(decision_vector, np.ndarray):
            raise TypeError("The expected type of `decision_vector` is `np.ndarray`")

        fit = 0

        for i in range(self.n):
            if decision_vector[i] == 1:
                for j in range(i+1):
                    if decision_vector[j] == 1:
                        fit += self.qs[function_id][i][j]

        return - fit

    def generate_random_solution(self):
        """
        Generate a random solution for the current problem

        :return: {:class:`~moead_framework.solution.one_dimension_solution.OneDimensionSolution`}
        """

        return self.evaluate(x=np.random.randint(0, 2, self.n).tolist()[:])

    def load_qs(self, file_content):
        """
        Load values of the instance file

        :param file_content: {list<float>} content of the instance file
        :return:
        """
        line = 0
        for i in range(self.n):
            for j in range(self.n):
                s = file_content[line].split("  ")
                line += 1
                for n in range(self.m):
                    self.qs[n][i][j] = int(s[n])
                pass

